<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Console - Battery Smart</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéß</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #0f172a, #1e293b);
            color: #f8fafc;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 24px;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 16px;
            margin-bottom: 20px;
            border: 1px solid rgba(59, 130, 246, 0.2);
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .logo-icon {
            font-size: 32px;
        }
        
        .logo-text h1 {
            font-size: 20px;
            font-weight: 600;
        }
        
        .logo-text span {
            font-size: 12px;
            color: #64748b;
        }
        
        .status-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 20px;
        }
        
        .status-badge.waiting {
            background: rgba(251, 191, 36, 0.1);
            border-color: rgba(251, 191, 36, 0.3);
        }
        
        .status-badge.waiting .status-dot {
            background: #fbbf24;
            animation: pulse 2s infinite;
        }
        
        .status-badge.in-call {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.3);
        }
        
        .status-badge.in-call .status-dot {
            background: #10b981;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #10b981;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }
        
        /* Main content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        /* Waiting state */
        .waiting-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 40px;
        }
        
        .waiting-icon {
            font-size: 80px;
            margin-bottom: 24px;
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        .waiting-state h2 {
            font-size: 28px;
            margin-bottom: 12px;
            color: #fbbf24;
        }
        
        .waiting-state p {
            color: #64748b;
            font-size: 16px;
            max-width: 400px;
        }
        
        /* Call panel (when in call) */
        .call-panel {
            flex: 1;
            display: none;
            flex-direction: column;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 16px;
            border: 1px solid rgba(59, 130, 246, 0.2);
            overflow: hidden;
        }
        
        .call-panel.active {
            display: flex;
        }
        
        .call-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 24px;
            background: linear-gradient(90deg, rgba(16, 185, 129, 0.1), rgba(59, 130, 246, 0.1));
            border-bottom: 1px solid rgba(59, 130, 246, 0.2);
        }
        
        .call-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .call-info .avatar {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, #10b981, #059669);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        
        .call-info .details h3 {
            font-size: 16px;
            font-weight: 600;
        }
        
        .call-info .details span {
            font-size: 13px;
            color: #10b981;
        }
        
        .call-actions {
            display: flex;
            gap: 12px;
        }
        
        .btn {
            padding: 10px 20px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }
        
        .btn-danger {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            color: #ef4444;
        }
        
        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.3);
        }
        
        .jitsi-container {
            flex: 1;
            min-height: 500px;
        }
        
        .jitsi-container iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        /* Incoming call alert */
        .incoming-alert {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: alertPulse 1s infinite;
        }
        
        .incoming-alert.active {
            display: flex;
        }
        
        @keyframes alertPulse {
            0%, 100% { background: rgba(0, 0, 0, 0.9); }
            50% { background: rgba(16, 185, 129, 0.2); }
        }
        
        .incoming-alert .ring-icon {
            font-size: 100px;
            animation: ring 0.5s infinite;
        }
        
        @keyframes ring {
            0%, 100% { transform: rotate(-15deg); }
            50% { transform: rotate(15deg); }
        }
        
        .incoming-alert h2 {
            font-size: 32px;
            margin: 24px 0 12px;
            color: #10b981;
        }
        
        .incoming-alert p {
            color: #94a3b8;
            font-size: 18px;
            margin-bottom: 8px;
        }
        
        .incoming-alert .countdown {
            font-size: 48px;
            font-weight: bold;
            color: #fbbf24;
            margin: 20px 0;
        }
        
        .incoming-alert .btn-accept {
            padding: 16px 48px;
            font-size: 18px;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            animation: pulse 1s infinite;
        }
        
        /* Queue panel */
        .queue-panel {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 12px;
            border: 1px solid rgba(59, 130, 246, 0.2);
            padding: 16px;
        }
        
        .queue-panel h3 {
            font-size: 14px;
            color: #64748b;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .queue-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .queue-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }
        
        .queue-item .time {
            font-size: 12px;
            color: #64748b;
        }
        
        .empty-queue {
            color: #64748b;
            font-size: 14px;
            text-align: center;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="logo">
                <span class="logo-icon">üéß</span>
                <div class="logo-text">
                    <h1>Agent Console</h1>
                    <span>Battery Smart Customer Support</span>
                </div>
            </div>
            <div class="status-badge waiting" id="status-badge">
                <span class="status-dot"></span>
                <span id="status-text">Waiting for calls...</span>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <!-- Waiting State -->
            <div class="waiting-state" id="waiting-state">
                <div class="waiting-icon">üéß</div>
                <h2>Ready to Assist</h2>
                <p>Keep this page open. When a customer needs help, you'll be automatically connected.</p>
                <div style="margin-top: 24px; padding: 16px; background: rgba(59, 130, 246, 0.1); border-radius: 12px; border: 1px solid rgba(59, 130, 246, 0.3);">
                    <p style="color: #60a5fa; font-size: 13px;">üí° Make sure your microphone is enabled and browser notifications are allowed.</p>
                </div>
            </div>
            
            <!-- Call Panel (shown when in call) -->
            <div class="call-panel" id="call-panel">
                <div class="call-header">
                    <div class="call-info">
                        <div class="avatar">üë§</div>
                        <div class="details">
                            <h3>Customer Call</h3>
                            <span id="call-duration">‚óè Connected</span>
                        </div>
                    </div>
                    <div class="call-actions">
                        <button class="btn btn-danger" onclick="endCall()">
                            üìû End Call
                        </button>
                    </div>
                </div>
                <div class="jitsi-container" id="jitsi-container">
                    <!-- Jitsi iframe will be inserted here -->
                </div>
            </div>
            
            <!-- Recent Transfers Queue -->
            <div class="queue-panel">
                <h3>üìã Recent Transfers</h3>
                <div class="queue-list" id="queue-list">
                    <div class="empty-queue">No recent transfers</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Incoming Call Alert -->
    <div class="incoming-alert" id="incoming-alert">
        <div class="ring-icon">üìû</div>
        <h2>Incoming Customer Call!</h2>
        <p id="alert-reason">Customer requested human assistance</p>
        <div class="countdown" id="countdown">3</div>
        <p style="color: #64748b;">Auto-connecting...</p>
    </div>
    
    <!-- Audio for alert -->
    <audio id="ring-sound" preload="auto">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdH2LkpOQiX51b2Z0hI+VlI2Df3d0d4GKkJKPiIJ8eHh9hYuPkI2Ignx4eX6Ei4+QjYiCfHh5foWLj5CNiIJ8eHl+hIuPkI2Ignx4eH6Fi4+QjYeCfHh5foWLj5CNh4J8eHl+hYuPkI2Hgnx4eX6Fi4+QjYeCfHh5foWLj5CNh4J8eHl+hYuPkI2Hgnx4eX6Fi4+QjYeCfHh5foWLj5CNh4J8eHl+hYuPkI2Hgnx4" type="audio/wav">
    </audio>
    
    <script src="https://meet.jit.si/external_api.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        // Socket connection
        let socket = null;
        let currentCall = null;
        let jitsiApi = null;
        let callStartTime = null;
        let durationInterval = null;
        
        // DOM elements
        const waitingState = document.getElementById('waiting-state');
        const callPanel = document.getElementById('call-panel');
        const jitsiContainer = document.getElementById('jitsi-container');
        const incomingAlert = document.getElementById('incoming-alert');
        const statusBadge = document.getElementById('status-badge');
        const statusText = document.getElementById('status-text');
        const queueList = document.getElementById('queue-list');
        const ringSound = document.getElementById('ring-sound');
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            initializeSocket();
            requestNotificationPermission();
        });
        
        function initializeSocket() {
            socket = io(window.location.origin, {
                transports: ['websocket', 'polling']
            });
            
            socket.on('connect', () => {
                console.log('‚úÖ Connected to server with socket ID:', socket.id);
                updateStatus('waiting', 'Registering...');
                // Register as agent
                const agentId = 'agent-' + Date.now();
                console.log('üì§ Sending agent_register with ID:', agentId);
                socket.emit('agent_register', { agent_id: agentId });
            });
            
            socket.on('agent_registered', (data) => {
                console.log('‚úÖ Agent registration confirmed:', data);
                updateStatus('waiting', 'Waiting for calls...');
            });
            
            socket.on('disconnect', () => {
                console.log('‚ùå Disconnected from server');
                updateStatus('disconnected', 'Disconnected - Reconnecting...');
            });
            
            // Listen for transfer requests
            socket.on('agent_incoming_call', (data) => {
                console.log('='  .repeat(60));
                console.log('üìû INCOMING CALL RECEIVED!');
                console.log('   Session ID:', data.session_id);
                console.log('   Room Name:', data.room_name);
                console.log('   Room URL:', data.room_url);
                console.log('   Reason:', data.reason);
                console.log('   Full data:', JSON.stringify(data, null, 2));
                console.log('=' .repeat(60));
                handleIncomingCall(data);
            });
            
            // =========================================================================
            // WEBRTC SOCKET HANDLERS
            // =========================================================================
            
            // Queue for pending offers (in case offer arrives before peerConnection is ready)
            window.pendingOffer = null;
            
            // Handle WebRTC offer from customer
            socket.on('webrtc_offer', async (data) => {
                console.log('üì° Received WebRTC offer from customer');
                
                if (window.peerConnection && data.offer) {
                    await handleWebRTCOffer(data);
                } else {
                    // Peer connection not ready yet, queue the offer
                    console.log('‚è≥ Peer connection not ready, queuing offer...');
                    window.pendingOffer = data;
                }
            });
            
            // Queue for ICE candidates that arrive before remote description is set
            window.pendingIceCandidates = [];
            
            // Handle ICE candidates from customer
            socket.on('webrtc_ice_candidate', async (data) => {
                if (data.candidate) {
                    // Check if peer connection exists and has remote description
                    if (window.peerConnection && window.peerConnection.remoteDescription) {
                        try {
                            await window.peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                        } catch (e) {
                            console.error('Error adding ICE candidate:', e);
                        }
                    } else {
                        // Queue the candidate for later
                        console.log('‚è≥ Queuing ICE candidate (remote description not set yet)');
                        window.pendingIceCandidates.push(data.candidate);
                    }
                }
            });
            
            // Handle hangup from customer
            socket.on('webrtc_hangup', (data) => {
                console.log('üì¥ Customer ended the call');
                endCall();
            });
            
            // Receive transcripts from customer
            socket.on('call_transcript', (data) => {
                console.log('üìù Received transcript from customer:', data);
                addAgentTranscript(data.speaker, data.text);
            });
        }
        
        function requestNotificationPermission() {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        }
        
        function handleIncomingCall(data) {
            console.log('üîî handleIncomingCall called with:', data);
            currentCall = data;
            
            // Play alert sound
            try {
                ringSound.currentTime = 0;
                ringSound.play().catch(() => {});
            } catch (e) {}
            
            // Show browser notification
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification('üìû Customer needs help!', {
                    body: data.reason === 'customer_request' ? 'Customer requested human agent' : 'AI transferred the call',
                    icon: 'üìû',
                    requireInteraction: true
                });
            }
            
            // Update alert reason
            document.getElementById('alert-reason').textContent = 
                data.reason === 'customer_request' 
                    ? 'Customer requested to speak with a human' 
                    : 'AI agent transferred for better assistance';
            
            // Show incoming alert with countdown
            incomingAlert.classList.add('active');
            
            let countdown = 3;
            const countdownEl = document.getElementById('countdown');
            countdownEl.textContent = countdown;
            
            const countdownInterval = setInterval(() => {
                countdown--;
                countdownEl.textContent = countdown;
                
                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                    incomingAlert.classList.remove('active');
                    ringSound.pause();
                    joinCall(data);
                }
            }, 1000);
            
            // Add to queue
            addToQueue(data);
        }
        
        async function joinCall(data) {
            console.log('üéØ Joining call with data:', data);
            
            // Update status
            updateStatus('in-call', 'In Call');
            statusBadge.classList.remove('waiting');
            statusBadge.classList.add('in-call');
            
            // Hide waiting, show call panel
            waitingState.style.display = 'none';
            callPanel.classList.add('active');
            
            // Store call data
            currentCall = data;
            window.customerSocketId = data.customer_sid;
            
            // Show connecting UI
            jitsiContainer.innerHTML = `
                <div style="padding: 40px; text-align: center;">
                    <div style="font-size: 64px; margin-bottom: 20px; animation: pulse 1s infinite;">üìû</div>
                    <h3 style="color: #10b981; margin-bottom: 12px;">Connecting to Customer...</h3>
                    <p style="color: #94a3b8;">Setting up secure audio connection</p>
                </div>
                <style>@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }</style>
            `;
            
            // Start duration timer
            callStartTime = Date.now();
            durationInterval = setInterval(updateDuration, 1000);
            
            // Notify server that agent joined - this will trigger customer to send WebRTC offer
            socket.emit('agent_joined_call', {
                session_id: data.session_id,
                room_name: data.room_name,
                customer_sid: data.customer_sid
            });
            
            // Setup WebRTC to receive call
            await setupWebRTCReceiver(data);
        }
        
        // =============================================================================
        // WEBRTC FOR AGENT
        // =============================================================================
        
        async function setupWebRTCReceiver(data) {
            console.log('üéôÔ∏è Setting up WebRTC receiver for customer call');
            
            // Check if mediaDevices is available (requires HTTPS or localhost)
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.error('‚ùå getUserMedia not available - need HTTPS or localhost');
                jitsiContainer.innerHTML = `
                    <div style="padding: 40px; text-align: center;">
                        <div style="font-size: 64px; margin-bottom: 20px;">üîí</div>
                        <h3 style="color: #fbbf24; margin-bottom: 12px;">Secure Connection Required</h3>
                        <p style="color: #94a3b8; margin-bottom: 16px;">Microphone access requires a secure connection.</p>
                        <p style="color: #64748b; font-size: 13px;">Please access this page using:</p>
                        <code style="display: block; background: rgba(0,0,0,0.3); padding: 8px 16px; border-radius: 6px; margin-top: 8px; color: #10b981;">http://localhost:5000/agent-console/</code>
                    </div>`;
                return;
            }
            
            try {
                // Get agent's microphone
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                window.localStream = stream;
                console.log('‚úÖ Got local audio stream');
                
                // Create peer connection
                const config = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ]
                };
                
                window.peerConnection = new RTCPeerConnection(config);
                
                // Add local audio track
                stream.getTracks().forEach(track => {
                    window.peerConnection.addTrack(track, stream);
                });
                
                // Handle incoming audio from customer
                window.peerConnection.ontrack = (event) => {
                    console.log('üîä Received audio from customer');
                    const remoteAudio = document.getElementById('remote-customer-audio') || createRemoteAudio();
                    remoteAudio.srcObject = event.streams[0];
                    remoteAudio.play().catch(e => console.log('Auto-play blocked:', e));
                };
                
                // Handle ICE candidates
                window.peerConnection.onicecandidate = (event) => {
                    if (event.candidate && data.customer_sid) {
                        socket.emit('webrtc_ice_candidate', {
                            session_id: data.session_id,
                            candidate: event.candidate,
                            target_sid: data.customer_sid
                        });
                    }
                };
                
                // Connection state changes
                window.peerConnection.onconnectionstatechange = () => {
                    console.log('WebRTC connection state:', window.peerConnection.connectionState);
                    
                    switch (window.peerConnection.connectionState) {
                        case 'connected':
                            updateCallUI('connected');
                            startAgentSpeechRecognition(data);
                            break;
                        case 'disconnected':
                        case 'failed':
                            endCall();
                            break;
                    }
                };
                
                console.log('‚úÖ Peer connection created, checking for pending offer...');
                
                // Process any pending offer that arrived before peer connection was ready
                if (window.pendingOffer) {
                    console.log('üì° Processing pending WebRTC offer');
                    await handleWebRTCOffer(window.pendingOffer);
                    window.pendingOffer = null;
                }
                
            } catch (error) {
                console.error('‚ùå WebRTC setup error:', error);
                jitsiContainer.innerHTML = `
                    <div style="padding: 40px; text-align: center;">
                        <div style="font-size: 64px; margin-bottom: 20px;">‚ùå</div>
                        <h3 style="color: #ef4444; margin-bottom: 12px;">Microphone Error</h3>
                        <p style="color: #94a3b8;">${error.message}</p>
                    </div>`;
            }
        }
        
        // Handle WebRTC offer from customer
        async function handleWebRTCOffer(data) {
            try {
                console.log('üîÑ Processing WebRTC offer...');
                await window.peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                console.log('‚úÖ Remote description set successfully');
                
                // Process any pending ICE candidates
                if (window.pendingIceCandidates && window.pendingIceCandidates.length > 0) {
                    console.log(`üì° Processing ${window.pendingIceCandidates.length} pending ICE candidates`);
                    for (const candidate of window.pendingIceCandidates) {
                        try {
                            await window.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                        } catch (e) {
                            console.error('Error adding queued ICE candidate:', e);
                        }
                    }
                    window.pendingIceCandidates = [];
                }
                
                const answer = await window.peerConnection.createAnswer();
                await window.peerConnection.setLocalDescription(answer);
                
                socket.emit('webrtc_answer', {
                    session_id: data.session_id,
                    answer: answer,
                    target_sid: data.from_sid
                });
                console.log('üì§ Sent WebRTC answer to customer');
                
                // Store customer socket ID
                window.customerSocketId = data.from_sid;
                
            } catch (e) {
                console.error('Error handling WebRTC offer:', e);
            }
        }
        
        function createRemoteAudio() {
            const audio = document.createElement('audio');
            audio.id = 'remote-customer-audio';
            audio.autoplay = true;
            audio.style.display = 'none';
            document.body.appendChild(audio);
            return audio;
        }
        
        function updateCallUI(state) {
            if (state === 'connected') {
                jitsiContainer.innerHTML = `
                    <div style="padding: 20px;">
                        <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 20px;">
                            <div style="width: 60px; height: 60px; background: linear-gradient(135deg, #10b981, #059669); border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                                <span style="font-size: 28px;">üë§</span>
                            </div>
                            <div>
                                <h3 style="color: white; margin: 0;">Customer</h3>
                                <div style="color: #10b981; font-size: 14px;">üü¢ Voice Connected</div>
                            </div>
                        </div>
                        <div style="background: rgba(15, 23, 42, 0.8); border-radius: 12px; padding: 16px; border: 1px solid rgba(59, 130, 246, 0.3);">
                            <div style="color: #94a3b8; font-size: 13px; margin-bottom: 8px;">üìù Live Transcript</div>
                            <div id="agent-transcript" style="max-height: 300px; overflow-y: auto; font-size: 14px;"></div>
                        </div>
                    </div>
                `;
            }
        }
        
        function startAgentSpeechRecognition(data) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                console.warn('Speech Recognition not supported');
                return;
            }
            
            window.agentRecognition = new SpeechRecognition();
            window.agentRecognition.continuous = true;
            window.agentRecognition.interimResults = false;
            window.agentRecognition.lang = 'en-IN';
            
            window.agentRecognition.onresult = (event) => {
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    if (event.results[i].isFinal) {
                        const text = event.results[i][0].transcript.trim();
                        if (text) {
                            console.log('üé§ Agent said:', text);
                            addAgentTranscript('agent', text);
                            // Send to customer
                            if (data.customer_sid) {
                                socket.emit('call_transcript', {
                                    session_id: data.session_id,
                                    text: text,
                                    speaker: 'agent',
                                    target_sid: data.customer_sid
                                });
                            }
                        }
                    }
                }
            };
            
            window.agentRecognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                if (event.error !== 'no-speech') {
                    setTimeout(() => {
                        if (window.agentRecognition && window.peerConnection?.connectionState === 'connected') {
                            try { window.agentRecognition.start(); } catch(e) {}
                        }
                    }, 1000);
                }
            };
            
            window.agentRecognition.onend = () => {
                if (window.peerConnection?.connectionState === 'connected') {
                    try { window.agentRecognition.start(); } catch(e) {}
                }
            };
            
            try {
                window.agentRecognition.start();
                console.log('üé§ Started agent speech recognition');
            } catch(e) {
                console.error('Failed to start speech recognition:', e);
            }
        }
        
        function addAgentTranscript(speaker, text) {
            const transcript = document.getElementById('agent-transcript');
            if (!transcript) return;
            
            const entry = document.createElement('div');
            entry.style.cssText = `
                margin-bottom: 8px;
                padding: 8px 12px;
                border-radius: 8px;
                background: ${speaker === 'agent' ? 'rgba(59, 130, 246, 0.15)' : 'rgba(16, 185, 129, 0.15)'};
                border-left: 3px solid ${speaker === 'agent' ? '#3b82f6' : '#10b981'};
            `;
            
            const time = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            entry.innerHTML = `
                <div style="font-size: 11px; color: #64748b; margin-bottom: 4px;">
                    ${speaker === 'agent' ? 'üéß You' : 'üë§ Customer'} ‚Ä¢ ${time}
                </div>
                <div style="color: #e2e8f0;">${text}</div>
            `;
            
            transcript.appendChild(entry);
            transcript.scrollTop = transcript.scrollHeight;
        }
        
        function updateDuration() {
            if (!callStartTime) return;
            const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
            const mins = Math.floor(elapsed / 60);
            const secs = elapsed % 60;
            document.getElementById('call-duration').textContent = 
                `‚óè ${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function endCall() {
            console.log('üì¥ Ending call');
            
            // Clear timer
            if (durationInterval) {
                clearInterval(durationInterval);
                durationInterval = null;
            }
            
            // Stop WebRTC
            if (window.localStream) {
                window.localStream.getTracks().forEach(track => track.stop());
                window.localStream = null;
            }
            
            if (window.peerConnection) {
                // Notify customer before closing
                if (window.customerSocketId && currentCall) {
                    socket.emit('webrtc_hangup', {
                        session_id: currentCall.session_id,
                        target_sid: window.customerSocketId
                    });
                }
                window.peerConnection.close();
                window.peerConnection = null;
            }
            
            // Stop speech recognition
            if (window.agentRecognition) {
                try { window.agentRecognition.stop(); } catch(e) {}
                window.agentRecognition = null;
            }
            
            // Remove remote audio
            const remoteAudio = document.getElementById('remote-customer-audio');
            if (remoteAudio) remoteAudio.remove();
            
            // Clear Jitsi container
            jitsiContainer.innerHTML = '';
            
            // Update UI
            callPanel.classList.remove('active');
            waitingState.style.display = 'flex';
            
            // Update status
            updateStatus('waiting', 'Waiting for calls...');
            statusBadge.classList.remove('in-call');
            statusBadge.classList.add('waiting');
            
            // Notify server
            if (currentCall) {
                socket.emit('agent_ended_call', {
                    session_id: currentCall.session_id
                });
            }
            
            currentCall = null;
            callStartTime = null;
            window.customerSocketId = null;
        }
        
        function updateStatus(status, text) {
            statusText.textContent = text;
        }
        
        function addToQueue(data) {
            const emptyMsg = queueList.querySelector('.empty-queue');
            if (emptyMsg) emptyMsg.remove();
            
            const time = new Date().toLocaleTimeString();
            const item = document.createElement('div');
            item.className = 'queue-item';
            item.innerHTML = `
                <span>üìû</span>
                <span>Session ${data.session_id}</span>
                <span class="time">${time}</span>
            `;
            queueList.insertBefore(item, queueList.firstChild);
            
            // Keep only last 5
            while (queueList.children.length > 5) {
                queueList.removeChild(queueList.lastChild);
            }
        }
    </script>
</body>
</html>
